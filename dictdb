#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
# Copyright (C) 2017 by the-c0d3r
# Author: the-c0d3r
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 3, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.

# BUG: somehow it seems very slow to launch on first try, is python trying to create cache and the process is too slow??

import argparse
import editor
import tinydb
import re

from lib.db import Database
from lib.entry import Entry


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(prog="Dictionary Database")
    parser.add_argument("-i", "--interactive", help="interactive mode")
    parser.add_argument("-s", "--search", help="search word")
    parser.add_argument("-a", "--add", help="add new word")
    parser.add_argument("-d", "--delete", help="delete word")
    parser.add_argument("-m", "--modify", help="modify the existing definitions")
    parser.add_argument("-l", "--list", action="store_true", help="list all words (tip: use 'more')")
    # TODO: add official dictionary lookup

    return parser


class Controller:
    def __init__(self):
        self._db = Database()

        self.pattern = re.compile(r"(\S+):\s?(.+)")

        parser = build_parser()
        args = parser.parse_args()

        args_list = [
            args.interactive, args.search, args.add,
            args.delete, args.list, args.modify
        ]

        if not any(args_list):
            parser.print_help()
            exit()

        if args.add:
            self.add(args.add)

        if args.search:
            self.search(args.search)

        if args.interactive:
            self.interactive()

        if args.list:
            self.list()

        if args.modify:
            self.modify(args.modify)

        if args.delete:
            self.delete(args.delete)

    def interactive(self) -> None:
        pass

    def list(self) -> None:
        words = self._db.all()
        if not words:
            print("No words found in the database, start adding")
            return

        for pair in words:
            word = pair.get("word")
            definition = pair.get("definition")

            print("Word       : ", word)
            print("Definition : ", definition)
            print("\n")

    def add(self, data: str) -> None:
        try:
            [[word, definition]] = self.pattern.findall(data)
        except ValueError:
            # means parsing failed
            print("--add requires the data in the following format")
            print("--add 'word: (type) definition'")
            exit()
        else:
            entry = Entry(word = word, definition = definition)
            self._db.insert(entry.get_data())

    def search(self, data: str) -> None:
        results = self._db.query(data)

        if not results:
            print("Unable to find word in db")
            return

        for result in results:
            word = result.get("word")
            definition = result.get("definition")

            print("Word       : ", word)
            print("Definition : ", definition)
            print("\n")

    def delete(self, data: str) -> None:
        """Function to delete the entry"""
        results = self._db.query(data)

        if not results:
            print("Unable to find word in db")
            return

        return self._db.delete(data)

    def modify(self, data: str) -> None:
        """Function to modify the existing definitions"""
        results = self._db.query(data)

        if not results:
            print("Unable to find word in db")
            return

        if len(results) > 1:
            print(f"Multiple results found for {data}, please retry with exact word")
            return self.search(data)

        word = results[0].get("word")
        definition = results[0].get("definition")

        # acquire the new content from the editor
        raw = editor.edit(contents=f"{word}: {definition}")

        try:
            [[word, definition]] = self.pattern.findall(raw.decode().strip())
        except ValueError:
            print("Unable to parse the edited content, it must be in the following format, type is optional")
            print("word: (type) definition")
            return
        else:
            data = {'word': word, 'definition': definition}
            self._db.update(data)


if __name__ == "__main__":
    Controller()

